(defpackage egison.poker
  (:use :common-lisp
        :optima
        :egison)
  (:export :ModM
           :SuitM
           :CardM
           :card
           :poker-hand))
(in-package :egison.poker)

(defun ModM (n)
  #'(lambda (pattern value)
      (match pattern
        ((list 'val x) (if (eql (rem x n) (rem value n)) '(nil) nil))
        ((guard pvar (pattern-variable-p pvar)) `(((,pvar ,(SomethingM) ,(rem value n)))))
        (_ `(((,pattern ,(SomethingM) ,value)))))))

(defun SuitM () (EqM #'eq))

(defun CardM ()
  #'(lambda (pattern value)
      (match pattern
        ((list 'card psuit pnum)
         (match value
           ((list 'card vsuit vnum) `(((,psuit ,(SuitM) ,vsuit) (,pnum ,(ModM 13) ,vnum))))))
        (_ `(((,pattern ,(SomethingM) ,value)))))))

(defun poker-hand (cs)
  (match-first cs (MultisetM (CardM))
    ((cons (card s n)
           (cons (card $s $(+ n 1))
                 (cons (card $s $(+ n 2))
                       (cons (card $s $(+ n 3))
                             (cons (card $s $(+ n 4))
                                   ())))))
     "Straight flush")
    ((cons (card _ n)
           (cons (card _ $n)
                 (cons (card _ $n)
                       (cons (card _ $n)
                             _))))
     "Four of kind")
    ((cons (card _ m)
           (cons (card _ $m)
                 (cons (card _ $m)
                       (cons (card _ n)
                             (cons (card _ $n)
                                   ())))))
     "Full house")
    ((cons (card s _)
           (cons (card $s _)
                 (cons (card $s _)
                       (cons (card $s _)
                             (cons (card $s _)
                                   ())))))
     "Flush")
    ((cons (card _ n)
           (cons (card _ $(+ n 1))
                 (cons (card _ $(+ n 2))
                       (cons (card _ $(+ n 3))
                             (cons (card _ $(+ n 4))
                                   ())))))
     "Straight")
    ((cons (card _ n)
           (cons (card _ $n)
                 (cons (card _ $n)
                       _)))
     "Three of kind")
    ((cons (card _ m)
           (cons (card _ $m)
                 (cons (card _ n)
                       (cons (card _ $n)
                             _))))
     "Two pair")
    ((cons (card _ n)
           (cons (card _ $n)
                 _))
     "One pair")
    (_
     "Nothing")))
